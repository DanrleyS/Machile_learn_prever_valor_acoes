import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LinearRegression
import yfinance as yf

# Fun√ß√£o para baixar dados de uma a√ß√£o usando yfinance
def baixar_dados(ticker, inicio, fim):
    dados = yf.download(ticker, start=inicio, end=fim)
    return dados

# Baixar os dados hist√≥ricos da PETR4
ticker = 'PETR4.SA'
dados = baixar_dados(ticker, '2024-01-01', '2025-01-31')

# Calcular as m√©dias m√≥veis de 20 e 50 per√≠odos
dados['MM_20'] = dados['Close'].rolling(window=20).mean()
dados['MM_50'] = dados['Close'].rolling(window=50).mean()

# Remover valores NaN
dados.dropna(inplace=True)

# Exibir os dados ap√≥s remo√ß√£o dos NaNs
print("üîç Dados Ap√≥s Remover NaNs:")
print(dados[['Close', 'MM_20', 'MM_50']].tail())

# Normalizar os dados para a previs√£o
scaler = MinMaxScaler(feature_range=(0, 1))
dados_normalizados = scaler.fit_transform(dados[['Close', 'MM_20', 'MM_50']])

# Separando as vari√°veis independentes (X) e a vari√°vel dependente (y)
X = dados_normalizados[:, 1:]  # Usando MM_20 e MM_50
y = dados_normalizados[:, 0]  # Prevendo o pre√ßo de fechamento (Close)

# Dividir os dados em treino e teste
X_treino = X[:-1]  # Todos os dados menos o √∫ltimo
y_treino = y[:-1]
X_teste = X[-1:].reshape(1, -1)  # O √∫ltimo dado como teste

# Treinar o modelo de Regress√£o Linear
modelo = LinearRegression()
modelo.fit(X_treino, y_treino)

# Fazer a previs√£o para o √∫ltimo dia
previsoes_normalizadas = modelo.predict(X_teste)

# Reverter a normaliza√ß√£o para obter os valores reais das previs√µes
dados_novos = dados.iloc[[-1]].copy()  # √öltima linha dos dados
previsoes = scaler.inverse_transform(np.concatenate([dados_novos[['MM_20', 'MM_50']].values, previsoes_normalizadas.reshape(-1, 1)], axis=1))[:, -1]

# Adicionar a previs√£o revertida aos dados
dados_novos['Previsao_Revertida'] = previsoes

# Exibir os dados ap√≥s as previs√µes
print("üîç Dados Ap√≥s Previs√µes:")
print(dados_novos[['Close', 'Previsao_Revertida']])

# Resetar o √≠ndice para que 'Date' seja uma coluna normal
dados_novos_reset = dados_novos.reset_index()

# Plotar os resultados
plt.figure(figsize=(12, 6))

# Garantir que 'Date' seja convertida corretamente para datetime
dados_novos_reset['Date'] = pd.to_datetime(dados_novos_reset['Date'])

# Plotando as duas linhas: pre√ßo real e previs√£o revertida
plt.plot(dados['Close'], label="Pre√ßo Real", color="blue", linewidth=2)  # Pre√ßo Real
plt.scatter(dados_novos_reset["Date"], dados_novos_reset["Previsao_Revertida"], color="red", label="Previs√£o", zorder=5)  # Previs√£o

# Ajustar t√≠tulo e labels
plt.title(f"Previs√£o de Pre√ßo para {ticker}")
plt.xlabel("Data")
plt.ylabel("Pre√ßo (R$)")
plt.legend()
plt.grid()

# Ajustar a rota√ß√£o das datas no eixo X para legibilidade
plt.xticks(rotation=45)

# Exibir gr√°fico
plt.tight_layout()
plt.show()

print("‚úÖ Previs√µes geradas e exibidas no gr√°fico!")
